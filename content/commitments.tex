\chapter{Pedersen Commitments}
\label{chapter:pedersen-commitments}


Generally speaking, a cryptographic {\em commitment scheme} is a way of committing to a value without revealing the value itself.

For example, in a coin-flipping game Alice could privately commit to one outcome (i.e. ‘call it’) before Bob flips the coin by publishing her committed value hashed with secret data. After Bob flips the coin, Alice could declare which value she committed to and prove it by publishing her secret data. Bob could then verify her claim.

In other words, assume that Alice has a secret string $blah$ and the value she wants to commit to is $heads$. She could simply hash $h = \mathcal{H}(blah, heads)$ and give $h$ to Bob. Bob flips a coin, Alice tells Bob about $blah$ and informs him she committed to $heads$, and then Bob calculates $h’ = \mathcal{H}(blah, heads)$. If $h' = h$, then he knows Alice called $heads$ before the coin flip.

Alice uses the so-called `salt' $blah$ so Bob can't just guess $\mathcal{H}(heads)$ and $\mathcal{H}(tails)$ before his coin flip, and figure out she committed to $heads$.

\section{Pedersen commitments}
\label{pedersen_section}

A {\em Pedersen commitment} \cite{Pedersen1992} is a commitment that has the property of being {\em additively homomorphic}. If \(C(a)\) and \(C(b)\) denote the commitments for values \(a\) and \(b\) respectively, then \(C(a + b) = C(a) + C(b)\).\footnote{Additively homomorphic in this context means addition is preserved when you transform scalars into EC points by applying, for scalar $x$, $x \rightarrow x G$.} This property is useful when committing transaction amounts, as one could prove, for instance, that inputs equal outputs, without revealing the amounts at hand.
\\

Fortunately, Pedersen commitments are easy to implement with elliptic curve cryptography, as the following holds trivially \[a G + b G = (a + b) G\]

Clearly, by defining a commitment as simply \(C(a) = a G\), we could easily create cheat tables of commitments to help us recognize common amounts $a$.

To attain information-theoretic privacy, one needs to add a secret {\em blinding factor} and another generator \(H\), such that it is unknown for which value of \(\gamma\) the following holds: \(H = \gamma G\). The hardness of the discrete logarithm problem ensures calculating $\gamma$ from $H$ is infeasible. In the case of Monero, $H = \mathcal{H}_p(G)$.\footnote{\label{hashtopoint_note}The\marginnote{src/ringct/ rctTypes.h} Monero codebase has a function $to\_point()$ that maps scalars to EC points. For commitments, $H = to\_point(\mathit{Keccak}(G))$.}%see rctTypes.h

We can then define the commitment to an amount \(a\) as \(C(x, a) = x G + a H\), where \(x\) is a blinding factor that prevents observers from guessing $a$ (for example: if you just commit $C(a=1)$, it is trivial to guess and check). 

Commitment $C(x, a)$ is information-theoretically private because there are many possible combinations of $x$ and $a$ that would output the same $C$.\footnote{Basically, there are many $x’$ and $a’$ such that $x’+a’ \gamma = x+a \gamma$. A committer knows one combination, but an attacker has no way to know which one. Furthermore, even the committer can't find another combination without solving the DLP for $\gamma$.} If $x$ is truly random, an attacker would have literally no way to figure out $a$ \cite{maxwell-ct, SCOZZAFAVA1993313}.%{https://people.xiph.org/~greg/confidential_values.txt}
\\




\section{Amount commitments}
\label{sec:pedersen_monero}

Owning cryptocurrency is not like a bank account, where a person’s balance exists as a single value in a database. Rather, a person owns a bunch of transaction {\em outputs}. Each output has an `amount’, and the sum of amounts in all {\em unspent} outputs owned is considered a person’s balance.

To send cryptocurrency to someone else, we create a transaction. A transaction references old outputs as {\em inputs} and addresses new outputs to recipients. Once an output has been referenced, i.e. `spent', it can never be referenced/spent again.

Since it is rare for input amounts to equal intended output amounts, most transactions include `change’, an output that sends excess back to the sender. We will elaborate on these topics in Chapter \ref{chapter:transactions}.

In Monero, transaction amounts are hidden using a technique called RingCT, first implemented in January, 2017 (v4 of the protocol). While transaction verifiers don’t know how much Monero is contained in each input and output, they still need to prove the sum of input amounts equals the sum of output amounts. 

In other words, if we had a transaction with inputs containing amounts \(a_1, ..., a_m\) and outputs with amounts \(b_1, ..., b_p\), then an observer would justifiably expect that: \vspace{.2cm}
\[\sum_j a_j - \sum_t b_t = 0\]

Since commitments are additive and we don't know $\gamma$, we could easily prove our inputs equal outputs to observers by making the sum of commitments to input and output amounts equal zero:\footnote{Recall from Section \ref{elliptic_curves_section} we can subtract a point by inverting its coordinates. If $P = (x, y)$, $-P = (-x, y)$. Recall also that negations of field elements are calculated$\pmod q$, so $(–y \pmod q)$.}
\[\sum_{j}{C_{j, in}}     - \sum_{t}{C_{t, out}} = 0\]

To avoid sender identifiability, Shen Noether proposed \cite{MRL-0005} verifying that commitments sum to a certain non-zero value:\vspace{.2cm}
\begin{align*}
\sum_{j}{C_{j, in}}     - \sum_{t}{C_{t, out}} &= z G \\
\sum_{j}{(x_j G + a_j H)}  - \sum_{t}{(y_t G + b_t H)} &= z G \\
\sum_{j} x_j - \sum_{t} y_t &= z
\end{align*}

The reasons why this is useful will become clear in Chapter \ref{chapter:transactions} when we discuss the structure of transactions.

Note that $C = z G$ is called a {\em commitment to zero} because we can make a signature with $z$, which proves that there is no $H$ component to $C$ (assuming $\gamma$ is unknown). In other words $C = z G + 0 H$.



\section{Range proofs}
\label{sec:range_proofs}

One problem with additive commitments is that, if we have commitments $C(a_1)$, $C(a_2)$, $C(b_1)$, and $C(b_2)$ and we intend to use them to prove that $(a_1 + a_2) - (b_1 + b_2) = 0$, then those commitments would still apply if one value in the equation were `negative'.

For instance, we could have $a_1 = 6$, $a_2 = 5$, $b_1 = 21$, and $b_2 = -10$.\vspace{.2cm}
\begin{flalign*}
    && (6 + 5) - (&21 + -10) = 0&\\
     \intertext{\quad \quad \quad \quad \quad where} && 21G + -10G = 21G + (&l-10)G = (l + 11)G = 11G&
\end{flalign*}

Since $-10 = l-10$, we have effectively created $l$ more Moneroj (over 7.2x10$^{74}$!) than we put in.

The solution used in Monero is to prove that each output commitment is to a value within the range $[0,2^{64})$, which cannot be misused to form a negative-value representation to bypass the balance check. The proving system used for this purpose is Bulletproofs, described in \cite{bulletproofs}. Unlike earlier range proof systems, Bulletproofs scale in size logarithmically with the number of bits in the amount representation, making them extremely efficient.

In addition to efficient proofs for single commitments, it is possible to generate a single aggregate Bulletproof that shows each commitment in a set is within the proper range. This single proof also scales logarithmically with the number of commitments, but can only be generated with knowledge of all commitment values and masks; that is, it is not possible to take a collection of arbitrary single-commitment Bulletproofs and later combine them into an aggregate proof. Additionally, the number of commitments included in an aggregate proof must be a power of two. In the case where the number of commitments is not a power of two, dummy zero-value commitments are included (but not stored with the proof, as the verifier can identically reconstruct them).

The construction of Bulletproofs in Monero closely follows the paper \cite{bulletproofs}. However, group elements in the proof structure are offset by the scalar multiplier $8^{-1}$ prior to inclusion in transaction data. The verifier then multiplies each such point by the scalar multiplier $8$ before beginning the verification process. This recovers the original points used in the proof, while ensuring that all points lie within the correct curve subgroup.

Bulletproofs are efficient to verify. Given an arbitrary batch of proofs (whether aggregate or not), the verifier can use a single multiexponentiation operation to complete the verification of all proofs in the batch at once. The paper describes how to combine common curve group generators to make this process much faster than verifying each proof separately. In the event the batch verification fails, proofs can be checked individually or in smaller batches to identify failed proofs.

A transaction must have exactly one range proof. For an aggregate Bulletproof with $p$ commitments (where $p \leq 16$), the proof contains $5$ integers, $2 \lceil \log_2(64p) \rceil + 4$ curve points, and verifies using a simplified Pippenger multiexponentiation operation that combines fixed and variable base operations:

\begin{itemize}
    \setlength\itemsep{\listspace}
    \item [\textbf{MULT}] Multiexponentiation with $128p + 2$ fixed-base terms and $2 \lceil \log_2(64p) \rceil + p + 4$ variable-base terms
\end{itemize}
